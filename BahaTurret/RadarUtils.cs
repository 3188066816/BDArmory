//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
namespace BahaTurret
{
	public static class RadarUtils
	{
		public static Dictionary<Vessel,float> VesselBaseRadarSignatures = new Dictionary<Vessel, float>();

		public static void ScanInDirection(float directionAngle, Transform referenceTransform, float fov, Vector3 position, float minSignature, ref TargetSignatureData[] dataArray, float dataPersistTime)
		{
			Vector3d geoPos = VectorUtils.WorldPositionToGeoCoords(position, FlightGlobals.currentMainBody);
			Vector3 forwardVector = referenceTransform.forward;
			Vector3 upVector = VectorUtils.GetUpDirection(position);
			Vector3 lookDirection = Quaternion.AngleAxis(directionAngle, upVector) * forwardVector;

			int dataIndex = 0;
			foreach(var vessel in FlightGlobals.Vessels)
			{
				if(vessel.loaded)
				{
					if((vessel.transform.position-position).sqrMagnitude < 100) continue; //ignore self

					Vector3 vesselDirection = Vector3.ProjectOnPlane(vessel.CoM-position, upVector);
					if(Vector3.Angle(vesselDirection,lookDirection) < fov/2)
					{
						float sig = GetActualSignature(vessel, position);

						if(sig > minSignature)
						{
							while(dataIndex < dataArray.Length-1)
							{
								if((dataArray[dataIndex].exists && Time.time-dataArray[dataIndex].timeAcquired > dataPersistTime) || !dataArray[dataIndex].exists)
								{
									break;
								}
								dataIndex++;
							}
							if(dataIndex >= dataArray.Length) break;
							dataArray[dataIndex] = new TargetSignatureData(vessel, sig);
							dataIndex++;
							if(dataIndex >= dataArray.Length) break;
						}
					}
				}
			}
		}

		public static void ScanInDirection(Ray ray, float fov, float minSignature, ref TargetSignatureData[] dataArray, float dataPersistTime)
		{
			int dataIndex = 0;
			foreach(var vessel in FlightGlobals.Vessels)
			{
				if(vessel.loaded)
				{
					if((vessel.transform.position-ray.origin).sqrMagnitude < 10) continue; //ignore self

					if(Vector3.Angle(vessel.CoM-ray.origin, ray.direction) < fov/2)
					{
						float sig = GetActualSignature(vessel, ray.origin);

						if(sig > minSignature)
						{
							while(dataIndex < dataArray.Length-1)
							{
								if((dataArray[dataIndex].exists && Time.time-dataArray[dataIndex].timeAcquired > dataPersistTime) || !dataArray[dataIndex].exists)
								{
									break;
								}
								dataIndex++;
							}
							if(dataIndex >= dataArray.Length) break;
							dataArray[dataIndex] = new TargetSignatureData(vessel, sig);
							dataIndex++;
							if(dataIndex >= dataArray.Length) break;
						}
					}
				}
			}
		}

		public static float GetActualSignature(Vessel vessel, Vector3 origin)
		{
			float sig = GetBaseRadarSignature(vessel);
			Vector3 upVector = VectorUtils.GetUpDirection(origin);
			
			sig *= Mathf.Pow(15000,2)/(vessel.transform.position-origin).sqrMagnitude;
			
			if(vessel.Landed)
			{
				sig /= 550;
			}
			if(vessel.Splashed)
			{
				sig /= 250;
			}
			
			//notching
			float lookDownAngle = Vector3.Angle(vessel.transform.position-origin,upVector)-90;
			if(lookDownAngle > 10
			   && Vector3.Angle(vessel.srf_velocity, Vector3.ProjectOnPlane(vessel.srf_velocity,vessel.transform.position-origin)) < 10)
			{
				sig /= 220;
			}
			
			//extra ground clutter
			if(lookDownAngle > 20)
			{
				sig *= Mathf.Clamp01(FlightGlobals.getAltitudeAtPos(origin)/(100*(lookDownAngle-20)));
			}

			return sig;
		}

	

		public static float GetBaseRadarSignature(Vessel v)
		{
			if(!v.loaded)
			{
				return 0;
			}

			if(VesselBaseRadarSignatures.ContainsKey(v))
			{
				return VesselBaseRadarSignatures[v];
			}
			else
			{
				float size = 0;
				foreach(Part part in v.Parts)
				{
					if(!part) continue;

					if(part.mass > 0.2f)
					{
						foreach(var renderer in part.GetComponentsInChildren<MeshRenderer>())
						{
							Vector3 renderBounds = renderer.bounds.size;
							size += Mathf.Max (Mathf.Max (renderBounds.x,renderBounds.y),renderBounds.z);
						}
					}
				}

				VesselBaseRadarSignatures.Add(v,size);
				return size;
			}
		}

		public static Vector2 WorldToRadar(Vector3 worldPosition, Transform referenceTransform, Rect radarRect, float maxDistance)
		{
			float scale = maxDistance/(radarRect.height/2);
			Vector3 localPosition = referenceTransform.InverseTransformPoint(worldPosition);
			localPosition.y = 0;
			Vector2 radarPos = new Vector2((radarRect.width/2)+(localPosition.x/scale), (radarRect.height/2)-(localPosition.z/scale));
			return radarPos;
		}
		
		public static Vector2 WorldToRadarRadial(Vector3 worldPosition, Transform referenceTransform, Rect radarRect, float maxDistance, float maxAngle)
		{
			float scale = maxDistance/(radarRect.height);
			Vector3 localPosition = referenceTransform.InverseTransformPoint(worldPosition);
			localPosition.y = 0;
			float angle = Vector3.Angle(localPosition, Vector3.forward);
			if(localPosition.x < 0) angle = -angle;
			float xPos = (radarRect.width/2) + ((angle/maxAngle)*radarRect.width/2);
			Vector2 radarPos = new Vector2(xPos, (radarRect.height)-(localPosition.z/scale));
			return radarPos;
		}


	


	}
}

