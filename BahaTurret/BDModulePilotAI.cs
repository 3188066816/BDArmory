//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace BahaTurret
{
	public class BDModulePilotAI : PartModule
	{
		[KSPField(isPersistant = true)]
		public bool pilotEnabled = false;

		bool startedLanded = false;
		bool extending = false;

		Transform velocityTransform;

		Vessel targetVessel;

		Vector3 upDirection = Vector3.up;

		MissileFire wm;

		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Default Altitude"),
		 UI_FloatRange(minValue = 500f, maxValue = 4500f, stepIncrement = 25f, scene = UI_Scene.All)]
		public float defaultAltitude = 1200;
		
		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Min Altitude"),
		 UI_FloatRange(minValue = 150f, maxValue = 1500, stepIncrement = 10f, scene = UI_Scene.All)]
		public float minAltitude = 600;

		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "SteerFactor"),
		 UI_FloatRange(minValue = 0.1f, maxValue = 20f, stepIncrement = .1f, scene = UI_Scene.All)]
		public float steerMult = 8;
		//make a combat steer mult and idle steer mult
		
		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "SteerLimiter"),
		 UI_FloatRange(minValue = .1f, maxValue = 1f, stepIncrement = .05f, scene = UI_Scene.All)]
		public float maxSteer = 1;
		
		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "SteerDamping"),
		 UI_FloatRange(minValue = 0f, maxValue = 20f, stepIncrement = 0.1f, scene = UI_Scene.All)]
		public float steerDamping = 10;

		float threatLevel = 1;

		string debugString = string.Empty;

		void Start()
		{
			if(HighLogic.LoadedSceneIsFlight)
			{
				GameObject velocityObject = new GameObject("velObject");
				velocityObject.transform.position = transform.position;
				velocityObject.transform.parent = transform;
				velocityTransform = velocityObject.transform;

				part.OnJustAboutToBeDestroyed += DeactivatePilot;
				vessel.OnJustAboutToBeDestroyed += DeactivatePilot;

				if(pilotEnabled)
				{
					ActivatePilot();
				}
			}

			RefreshPartWindow();
		}

		[KSPAction("Activate Pilot")]
		public void AGActivatePilot(KSPActionParam param)
		{
			ActivatePilot();
		}

		[KSPAction("Deactivate Pilot")]
		public void AGDeactivatePilot(KSPActionParam param)
		{
			DeactivatePilot();
		}

		[KSPAction("Toggle Pilot")]
		public void AGTogglePilot(KSPActionParam param)
		{
			TogglePilot();
		}


		public void ActivatePilot()
		{
			pilotEnabled = true;
			vessel.OnFlyByWire += AutoPilot;
			startedLanded = vessel.Landed;

			RefreshPartWindow();
		}

		public void DeactivatePilot()
		{
			pilotEnabled = false;
			vessel.OnFlyByWire -= AutoPilot;
			RefreshPartWindow();
		}



		[KSPEvent(guiActive = true, guiName = "Toggle Pilot", active = true)]
		public void TogglePilot()
		{
			if(pilotEnabled)
			{
				DeactivatePilot();
			}
			else
			{
				ActivatePilot();
			}
		}

		void RefreshPartWindow()
		{
			Events["TogglePilot"].guiName = pilotEnabled ? "Deactivate Pilot" : "Activate Pilot";

			//Misc.RefreshAssociatedWindows(part);
		}


		void AutoPilot(FlightCtrlState s)
		{
			if(!vessel || !vessel.transform)
			{
				return;
			}

			GetGuardTarget();

			upDirection = -FlightGlobals.getGeeForceAtPosition(transform.position).normalized;
			debugString = string.Empty;

			if(MissileGuidance.GetRadarAltitude(vessel) < minAltitude)
			{
				startedLanded = true;
			}

			if(startedLanded)
			{
				TakeOff(s);
			}
			else
			{
				if(wm && wm.missileIsIncoming)
				{
					Evasive(s);
				}
				else if(targetVessel!=null)
				{
					bool forceExtend = false; //air2air force extend
					if(!targetVessel.Landed)
					{
						if(vessel.altitude < defaultAltitude && Vector3.Angle(targetVessel.transform.position-transform.position, -upDirection) < 35)
						{
							//dangerous if low altitude and target is far below you - don't dive into ground!
							forceExtend = true;
						}
					}

					if(targetVessel.Landed || forceExtend)
					{
						if(!extending)
						{
							bool targetTooClose = false;
							if(!forceExtend)
							{
								Vector3 localPos = vessel.ReferenceTransform.InverseTransformPoint(targetVessel.transform.position);
								if(localPos.y < 1000)
								{
									targetTooClose = true;
								}
								else
								{
									targetTooClose = false;
								}
							}
							if(targetTooClose || forceExtend)
							{
								extending = true;
							}
						}
					}
					else
					{
						extending = false;
					}

					if(extending)
					{
						threatLevel = 1;
						debugString += "\nExtending";
						FlyExtend(s, targetVessel.transform.position);
					}

					if(!extending)
					{
						debugString += "\nFlying to target";
						threatLevel = 1;
						FlyToTargetVessel(s, targetVessel);
					}
				}
				else
				{
					FlyCircular(s);
				}
			}

			debugString += "\nthreatLevel: "+threatLevel;
		}

		void FlyToTargetVessel(FlightCtrlState s, Vessel v)
		{
			Vector3 target = v.transform.position;

			if(wm)
			{
				MissileLauncher missile = wm.currentMissile;
				if(missile != null)
				{
					target = MissileGuidance.GetAirToAirFireSolution(missile, v);
            	}
			}


			FlyToPosition(s, target);

			//try airbrake if in front of enemy
			if(Vector3.Angle(vessel.ReferenceTransform.up, v.transform.position-vessel.transform.position) > 120 //angle to enemy is greater than 120
			   && (v.transform.position-vessel.transform.position).sqrMagnitude < Mathf.Pow(800, 2) //distance is less than 800m
			   && vessel.srfSpeed > 200) //airspeed is more than 200 
			{
				debugString += ("\nEnemy on tail. Braking");
				vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, true);
			}
			else
			{
				vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, false);
			}
		}

		void FlyToPosition(FlightCtrlState s, Vector3 targetPosition)
		{
			if(!startedLanded)
			{
				targetPosition = FlightPosition(targetPosition, minAltitude);
			}
			Transform vesselTransform = vessel.ReferenceTransform;
			velocityTransform.rotation = Quaternion.LookRotation(vessel.srf_velocity, -vesselTransform.forward);
			Vector3 localAngVel = vessel.angularVelocity;


			Vector3 targetDirection = velocityTransform.InverseTransformPoint(targetPosition).normalized;
			targetDirection = Vector3.RotateTowards(Vector3.forward, targetDirection, 15*Mathf.Deg2Rad, 0);
			
			float steerYaw = (steerMult/2 * targetDirection.x) - (steerDamping * -localAngVel.z);
			float steerPitch = (steerMult * targetDirection.y) - (steerDamping * -localAngVel.x);

			float finalMaxSteer = threatLevel * maxSteer;

			s.yaw = Mathf.Clamp(steerYaw, -finalMaxSteer, finalMaxSteer);
			s.pitch = Mathf.Clamp(steerPitch, -finalMaxSteer, finalMaxSteer);


			//roll
			Vector3 rollTarget = upDirection;
			if(Vector3.Angle(Vector3.forward, targetDirection) > 3)
			{
				rollTarget = Vector3.ProjectOnPlane(targetPosition-transform.position, vesselTransform.up) + (10f*upDirection);
			}

			Vector3 currentRoll = -vesselTransform.forward;
			float rollOffset = Misc.SignedAngle(currentRoll, rollTarget, vesselTransform.right);
			float steerRoll = (steerMult * 0.25f * rollOffset) - (50 * steerDamping * -localAngVel.y);

			s.roll = Mathf.Clamp(steerRoll, -maxSteer/2, maxSteer/2);
			//

			s.mainThrottle = 1;
		}

		void FlyExtend(FlightCtrlState s, Vector3 tPosition)
		{
			vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, false);
			if(wm)
			{
				float extendDistance = Mathf.Clamp(wm.guardRange-1800, 2500, 4000);
				if((GetSurfacePosition(tPosition)-GetSurfacePosition(vessel.transform.position)).sqrMagnitude < Mathf.Pow(extendDistance, 2))
				{
					Vector3 target = FlightPosition(transform.position + Vector3.ProjectOnPlane(1000*vessel.ReferenceTransform.up, upDirection), defaultAltitude);
					FlyToPosition(s, target);
				}
				else
				{
					extending = false;
				}
			}
			else
			{
				extending = false;
			}
		}

		void FlyCircular(FlightCtrlState s)
		{
			debugString += "\nFlying circular";
			vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, false);
			bool enemiesNearby = false;
			if(wm)
			{
				BDArmorySettings.BDATeams team = wm.team ? BDArmorySettings.BDATeams.B : BDArmorySettings.BDATeams.A;
				if(BDATargetManager.TargetDatabase[team].Count > 0)
				{
					threatLevel = 1;
					enemiesNearby = true;
				}
			}

			if(!enemiesNearby)
			{
				threatLevel = Mathf.MoveTowards(threatLevel, 0.5f, 0.05f*Time.deltaTime);
			}
			Vector3 axis = Vector3.Project(-vessel.ReferenceTransform.right, upDirection).normalized;
			Vector3 target = DefaultAltPosition() + Quaternion.AngleAxis(15, axis) * Vector3.ProjectOnPlane(vessel.ReferenceTransform.up * 1000, upDirection);
			FlyToPosition(s, target);
		}

		void Evasive(FlightCtrlState s)
		{
			debugString += "\nEvasive";
			threatLevel = 1f;
			Vector3 target = DefaultAltPosition() 
				+ (Quaternion.AngleAxis(Mathf.Sin (Time.time) * 80, upDirection) * Vector3.ProjectOnPlane(vessel.ReferenceTransform.up * 750, upDirection))
				+ (Mathf.Sin (Time.time/2) * upDirection * defaultAltitude/3);

			FlyToPosition(s, target);
		}

		void TakeOff(FlightCtrlState s)
		{
			threatLevel = 1;
			debugString += "\nTaking off/Gaining altitude";
			s.mainThrottle = 1;
			FlyToPosition(s, transform.position + Vector3.ProjectOnPlane(vessel.ReferenceTransform.up * 100, upDirection) + (upDirection * 50));
			vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, false);

			float radarAlt = MissileGuidance.GetRadarAltitude(vessel);

			if(radarAlt > 50)
			{
				vessel.ActionGroups.SetGroup(KSPActionGroup.Gear, false);
			}
			else
			{
				vessel.ActionGroups.SetGroup(KSPActionGroup.Gear, true);
			}

			if(radarAlt > minAltitude)
			{
				startedLanded = false;
			}
		}

		Vector3 DefaultAltPosition()
		{
			return (transform.position + (-(float)vessel.altitude*upDirection) + (defaultAltitude *upDirection));
		}

		Vector3 GetSurfacePosition(Vector3 position)
		{
			return position - ((float)FlightGlobals.getAltitudeAtPos(position) * upDirection);
		}


		Vector3 FlightPosition(Vector3 targetPosition, float minAlt)
		{
			float pointRadarAlt = MissileGuidance.GetRaycastRadarAltitude(targetPosition);
			if(pointRadarAlt < minAlt)
			{
				float adjustment = (minAlt-pointRadarAlt);
				debugString += "\nTarget position is below minAlt. Adjusting by "+adjustment;
				return targetPosition + (adjustment * upDirection);
			}
			else
			{
				return targetPosition;
			}
		}

		public bool GetLaunchAuthorizion(Vessel targetV, MissileFire mf)
		{
			bool launchAuthorized = false;
			Vector3 target = targetV.transform.position;
			MissileLauncher missile = mf.currentMissile;
			if(missile != null)
			{
				target = MissileGuidance.GetAirToAirFireSolution(missile, targetV);
			}

			if(Vector3.Angle(vessel.ReferenceTransform.up, target-vessel.ReferenceTransform.position) < 35 
			   || (targetV.Landed && Vector3.Angle(vessel.ReferenceTransform.up, FlightPosition(target, (float)vessel.altitude)-vessel.ReferenceTransform.position) < 15))
			{
				launchAuthorized = true;
			}

			return launchAuthorized;
		}

		void GetGuardTarget()
		{
			foreach(var mf in vessel.FindPartModulesImplementing<MissileFire>())
			{
				if(mf.currentTarget!=null)
				{
					targetVessel = mf.currentTarget.Vessel;
				}
				else
				{
					targetVessel = null;
				}

				wm = mf;
				mf.pilotAI = this;

				return;
			}
		}

		void OnGUI()
		{
			if(pilotEnabled && BDArmorySettings.DRAW_DEBUG_LABELS)	
			{
				GUI.Label(new Rect(200,600,400,400), debugString);	
			}
		}

	}
}

